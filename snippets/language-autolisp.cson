# AutoLISP snippets by @dtgoitia

# --------------------- AutoLISP
'.source.autolisp':
  list:
    prefix: 'list'
    body:   '(list\n\t$0\n);END list'
  if:
    prefix: 'if'
    body:   '(if ${1:condition}\n\t${2:single_function}\n);END if'
  cond:
    prefix: 'cond'
    body:   '(cond\n\t(${1:condition}\n\t\t${2:functions}\n\t);END subcond\n);END cond'
  subcond:
    prefix: 'scond'
    body:   '(${1:condition}\n\t${2:functions}\n);END subcond'
  defun:
    prefix: 'defun'
    body:   '
    (defun c:1 () (c:${1:name}) )\n(defun c:${1:MIRROR-name} ( / old_error old_sysvars )\n\n\t; SAVE SETTINGS\n\t; (save_environment (list "osmode" "angdir" "angbase"))\n\t\n\t${2:--- start here your program ---}\n\t\n\t; RESTORE SETTINGS\n\t; (restore_environment)\n\n\t(princ)\n\n\t; v0.0 - _DATE_ - First issue\n\t; Author: David Torralba\n\t; Last revision: _DATE_\n);END defun'
  "defun c\:1()":
    prefix: 'defun1'
    body:   '(defun c:1 () $0 )'
  "defun c\:xx()":
    prefix: 'dex'
    body:   '''
      (defun c:xx ()
      \t$0

      \t; v0.0 - ${1:_DATE_} - First issue
      \t; Author: David Torralba
      \t; Last revision: ${1:_DATE_}
      )
    '''
  "setq block":
    prefix: 'setq'
    body:   '''
      (setq
      \t$0
      );END setq
    '''
  progn:
    prefix: 'progn'
    body:   '(progn\n\t$0\n);END progn'
  princ:
    prefix: 'princ'
    body:   '(princ $0)'
  "test princ":
    prefix: 'princt'
    body:   '(princ "\\\\n${1:variable} = ")(princ ${1:variable})$2'
  while:
    prefix: 'while'
    body:   '(while ${1:condition}\n\t${2:functions}\n);END while'
  polar:
    prefix: 'polar'
    body:   '(polar ${1:point} ${2:angle} ${3:distance})'
  append:
    prefix: 'append'
    body:   '(append\n\t$0\n);END append'
  mapcar:
    prefix: 'mapcar'
    body:   '(mapcar\n\t${1:function_to_apply}\n\t${2:list_where_to_apply_function}\n);END mapcar'
  OK:
    prefix: 'ok'
    body:   '(princ "\\\\nOK")'
  issue:
    prefix: 'issue'
    body:   '; v0.0 - ${1:date} - First issue\n; Author: David Torralba\n; Last revision: ${1:date}'
  foreach:
    prefix: 'foreach'
    body:   '(foreach a ${1:list}\n\t${2:functions}\n);END foreach'
  and:
    prefix: 'and'
    body:   '(and\n\t$0\n);END and'
  or:
    prefix: 'or'
    body:   '(or\n\t$0\n);END or'
  strcat:
    prefix: 'strcat'
    body:   '(strcat\n\t$0\n);END strcat'
  cons:
    prefix: 'cons'
    body:   '(cons $0)'
  repeat:
    prefix: 'repeat'
    body:   '(repeat ${1:numberOfReps}\n\t${2:functions}\n);END repeat'

# VL, VLA and VLAX functions

  'vla-delete':
    prefix: 'vlaDel'
    body:   '(vla-delete ${1:object})'
  'vlax-get-acad-object':
    prefix: 'vlaGetAcad'
    body:   '(vlax-get-acad-object)'
  'vla-get-activeDocument':
    prefix: 'vlaGetActDoc'
    body:   '(vla-get-ActiveDocument ${1:acadObject})'
  'vla-startUndoMark':
    prefix: 'vlaStartUndo'
    body:   '(vla-startUndoMark ${1:documentObject})'
  'vla-endUndoMark':
    prefix: 'vlaEndUndo'
    body:   '(vla-endUndoMark ${1:documentObject})'
  'vla-offset':
    prefix: 'vlaOffset'
    body:   '(vla-offset ${1:object} ${2:offsetDistance})'
  'ename -> vla':
    prefix: 'ename2vla'
    body:   '(vlax-ename->vla-object ${1:ent_name})'
  'vla -> ename':
    prefix: 'vla2ename'
    body:   '(vlax-vla-object->ename ${1:VL_ent_name})'

  # Property-handling
  'vlax-get-property':
    prefix: 'getprop'
    body:   '(vlax-get-property ${1:object} ${2:propertyValue})'
  'vlax-put-property':
    prefix: 'putprop'
    body:   '(vlax-put-property ${1:object} ${2:property} \${3:propertyValue})'
  'vlax-dump-object':
    prefix: 'dump'
    body:   '(vlax-dump-object ${1:object})'
  'vlax-property-available-p':
    prefix: 'propAvailable'
    body:   '(vlax-property-available-p ${1:object} ${2:property})'

  # Curve measurement
  'vlax-curve-getArea':
    prefix: 'getArea'
    body:   '(vlax-curve-getArea ${1:object})'
  'vlax-curve-getClosestPointTo':
    prefix: 'getClosestPointTo'
    body:   '(vlax-curve-getClosestPointTo ${1:object} ${2:point})'
  'vlax-curve-getDistAtParam':
    prefix: 'getDistAtParam'
    body:   '(vlax-curve-getDistAtParam ${1:object} ${2:param})'
  'vlax-curve-getDistAtPoint':
    prefix: 'getDistAtPoint'
    body:   '(vlax-curve-getDistAtPoint ${1:object} ${2:point})'
  'vlax-curve-getEndParam':
    prefix: 'getEndParam'
    body:   '(vlax-curve-getEndParam ${1:object})'
  'vlax-curve-getEndPoint':
    prefix: 'getEndPoint'
    body:   '(vlax-curve-getEndPoint ${1:object})'
  'vlax-curve-getParamAtDist':
    prefix: 'getParamAtDist'
    body:   '(vlax-curve-getParamAtDist ${1:object} ${2:point})'
  'vlax-curve-getParamAtPoint':
    prefix: 'getParamAtPoint'
    body:   '(vlax-curve-getParamAtPoint ${1:object} ${2:distance})'
  'vlax-curve-getPointAtDist':
    prefix: 'getPointAtDist'
    body:   '(vlax-curve-getPointAtDist ${1:object} ${2:distance})'
  'vlax-curve-getPointAtParam':
    prefix: 'getPointAtParam'
    body:   '(vlax-curve-getPointAtParam ${1:object} ${2:param})'
  'vlax-curve-getStartPoint':
    prefix: 'getStartPoint'
    body:   '(vlax-curve-getStartPoint ${1:object})'

  # File handling

  'vl-filename-base':
    prefix: 'vlaFileNameBase'
    body:   '(vl-filename-base ${1:fileName})'
  'vl-filename-directory':
    prefix: 'vlaFileDirectory'
    body:   '(vl-filename-directory ${1:fileName})'
  'vl-filename-extension':
    prefix: 'vlaFileExtension'
    body:   '(vl-filename-extension ${1:fileName})'
  'vl-mkdir':
    prefix: 'mkdir'
    body:   '(vl-mkdir ${1:fullPath})'

# Custom snippets

  'single argument management':
    prefix: 'SingleArg'
    body:   '''
    (if ${1:variable}
      (if (= '${2:varType} (type ${1:variable}))
        single_function
        (progn (princ "\\\\nERROR @ ${3:function} : ${1:variable} is not a ${2:varType}\\\\n") nil )
      );END if
      (progn (princ "\\\\nERROR @ ${3:function} : ${1:variable}=nil\\\\n") nil )
    );END if
    '''
  'LM effectivename':
    prefix: 'LM effective'
    body:   '(LM:effectivename ${1:object})'
